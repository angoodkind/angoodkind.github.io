---
id: 188
title: Programmers and Pens
date: 2014-08-17T12:14:51-06:00
author: angoodkind
layout: post
guid: http://adamgoodkind.com/?p=188
permalink: /blog/programmers-and-pens/
dsq_thread_id:
  - "4408494095"
categories:
  - Programming
  - Technology
---
To be an outstanding novelist, a writer need not be intimately familiar with the ink-making or printing-press processes. This, however, is the exact state of computer programming today.

Although I only really use high-level languages like Java and Python on a day-to-day basis, I&#8217;m constantly employing the more fundamental knowledge I picked up when learning lower-level, more primitive languages, like C++ or Unix. Although knowledge of the latter languages is not &#8220;necessary&#8221; for programming in the former languages, familiarity with memory allocation and pointers allows me to write more efficient, more robust programs. And more robust programs allow me to test more hypotheses, and do better research.<img class="alignright" src="http://a57.foxnews.com/global.fbnstatic.com/static/managed/img/fb2/feeds/Associated%20Press/2014/07/10/660/371/Germany%20Jewish%20Museum-3.jpg?ve=1&tl=1" alt="" width="338" height="190" /> 

In the abbots of Medieval monasteries, monks were intimately familiar with how to grind up berries for ink, and stretch out animal hides for parchment. This was necessary knowledge to be a &#8220;writer.&#8221; Even into the mid 20th century, writers had to know how a pen holds its ink, constantly refilling it, and preventing blotting.

In Daniel Lemire&#8217;s most [recent blog post](http://lemire.me/blog/archives/2014/08/15/should-we-train-more-people-as-programmers/), he espouses the view that learning programming is not for everyone, since it&#8217;s hard. To be a good programmer requires a lot of work, and being comfortable with delving into technical minutiae.

I love Daniel&#8217;s blog, and have [previous commented](http://adamgoodkind.com/blog/nothing-is-ever-easy/) on [his thoughts.](http://lemire.me/blog/archives/2013/12/24/on-human-intelligence-a-perspective-from-computer-science/?utm_source=feedburner&utm_medium=twitter&utm_campaign=Feed%3A+daniel-lemire%2Fatom+%28Daniel+Lemire%27s+blog%29) I think his most recent post, though, shows exactly where we are in the progression of programming, and the dangers that lurk in the immediate future: Programmers are still Benedictine monks, cloistered in hilltop abbeys, showering gifts and knowledge unto the unlearned masses.

Perhaps an argument could be made that the Dark Ages were the result of just this type of schism in knowledge, with one class being scholarly and imbued in the transmission of ideas, while the peasant class was forced to do manual labor and till the fields. There is no reason to assume that a similar division of classes is not imminent, between programmers and non-programmers.

If we train more computer programmers, then we don&#8217;t need to worry about a future in which most jobs have been replaced by robots, and the majority of the population is on welfare, or doing mindless tasks. Concerns like these take a myopic view of the future, in which the occupations that currently exist will be the jobs that always exist. 100 years ago, we could not imagine half the jobs that exist today, like &#8220;Radiology Technician,&#8221; or &#8220;Software QA Engineer.&#8221; There is no reason to suppose that we haven&#8217;t even fathomed 1% of the jobs that will exist 100 years in the future.

However, we need to radically shift our point of view, and concentrate on the accessibility of programming, rather than its exclusiveness, in order to avoid this. There is no shortage of elitism in the programming world. But if we allow this elitism to run rampant, we could be looking at a future like this:



At least the singing and dancing will be good, though&#8230;

&nbsp;